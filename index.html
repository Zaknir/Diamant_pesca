<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diamant - Accessibile</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f0f0f0; }
        .container { max-width: 500px; margin: 0 auto; padding: 20px; background-color: white; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
        
        button { 
            padding: 15px; margin: 10px 0; border: 1px solid #333; border-radius: 5px; 
            cursor: pointer; font-weight: bold; width: 100%; font-size: 1.1em;
        }

        #primary-action-button { background-color: #4CAF50; color: white; }
        
        #extraction-log {
            border: 2px solid #2196F3;
            padding: 20px;
            margin-top: 15px;
            min-height: 80px;
            background-color: #fff;
            border-radius: 5px;
            font-size: 1.2em;
            text-align: center;
            outline: none;
        }
        
        .hazard { color: #d32f2f; font-weight: bold; }
        .treasure { color: #2e7d32; font-weight: bold; }
        .info { color: #1976d2; }
        p { margin: 0; }
    </style>
</head>
<body>

    <div class="container">
        <h1>Diamant</h1>
      
        <button id="primary-action-button">Inizia Nuova Spedizione (1)</button>

        <div id="extraction-log" 
             tabindex="-1">
            <p>Premi il pulsante per iniziare.</p>
        </div>
    </div>

    <script>
        let deck = [];
        let tunnel = [];
        let currentHazardCounts = {};
        let roundActive = false;
        let expeditionNumber = 0;
        const MAX_EXPEDITIONS = 5;
        const numPlayers = 4;

        let removedHazards = { 'Masso': 0, 'Serpente': 0, 'Ragno': 0, 'Fuoco': 0, 'Vapore': 0 };
        const MAX_HAZARDS_PER_TYPE = 3;

        const primaryActionButton = document.getElementById('primary-action-button');
        const extractionLog = document.getElementById('extraction-log');

        const BASE_DECK_CONFIG = {
            treasures: [1, 2, 3, 4, 5, 5, 7, 7, 9, 11, 11, 13, 14, 15, 17],
            ARTIFACT_VALUES: [5, 7, 8, 10, 12],
        };

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function logMessage(text, className = "") {
            extractionLog.innerHTML = `<p class="${className}">${text}</p>`;
            // Il focus() forzerÃ  lo screen reader a leggere solo questo contenuto una volta sola
            extractionLog.focus();
        }

        function createAndShuffleDeck() {
            let newDeck = [];
            BASE_DECK_CONFIG.treasures.forEach(v => newDeck.push({ type: 'treasure', value: v }));
            Object.keys(removedHazards).forEach(h => {
                const remaining = MAX_HAZARDS_PER_TYPE - (removedHazards[h] || 0);
                for (let i = 0; i < remaining; i++) newDeck.push({ type: 'hazard', value: h });
            });
            
            if (expeditionNumber <= 5) {
                newDeck.push({ type: 'artifact', gemValue: BASE_DECK_CONFIG.ARTIFACT_VALUES[expeditionNumber-1] });
            }

            shuffle(newDeck);
            return newDeck;
        }

        function drawCard() {
            if (!roundActive || deck.length === 0) return;

            const card = deck.pop();
            tunnel.push(card);
            let roundEnd = false;
            let logText = "";
            let logClass = "";

            if (card.type === 'hazard') {
                const hazardName = card.value;
                currentHazardCounts[hazardName] = (currentHazardCounts[hazardName] || 0) + 1;
                logClass = "hazard";
                
                if (currentHazardCounts[hazardName] === 2) {
                    roundEnd = true;
                    removedHazards[hazardName]++;
                    logText = `DOPPIO PERICOLO ${hazardName.toUpperCase()}! Spedizione fallita.`;
                } else {
                    logText = `Pericolo: ${hazardName} (1a volta).`;
                }
            } else if (card.type === 'treasure') {
                const gems = card.value;
                logClass = "treasure";
                logText = `Tesoro: ${gems} gemme. Dividetele equamente tra i giocatori e lasciate l'avanzo nella stanza`;
            } else if (card.type === 'artifact') {
                logClass = "info";
                logText = `Artefatto trovato (Valore ${card.gemValue}). Lasciatelo nello stanza`;
            }

            logMessage(logText, logClass);
            if (roundEnd) endExpedition();
            updateUI();
        }

        function startNewExpedition() {
            if (expeditionNumber >= MAX_EXPEDITIONS) return;
            expeditionNumber++;
            deck = createAndShuffleDeck();
            tunnel = [];
            currentHazardCounts = {};
            roundActive = true;
            
            logMessage(`Inizio Spedizione ${expeditionNumber}. Mazzo pronto.`, "info");
            updateUI();
        }

        function endExpedition() {
            roundActive = false;
        }

        function updateUI() {
            if (expeditionNumber === MAX_EXPEDITIONS && !roundActive) {
                primaryActionButton.textContent = 'Gioco Terminato';
                primaryActionButton.disabled = true;
            } else if (roundActive) {
                primaryActionButton.textContent = `Estrai Prossima Carta (Mazzo: ${deck.length})`;
            } else {
                primaryActionButton.textContent = `Inizia Spedizione ${expeditionNumber + 1}`;
            }
        }

        primaryActionButton.addEventListener('click', () => {
            if (roundActive) drawCard();
            else startNewExpedition();
        });
    </script>
</body>
</html>
